using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using TicketApi.Shared.Models.Entities;
using TicketApi.Features.Requirements.DTO;
using TicketApi.Features.Requirements.Services;
using TicketApi.Features.Authentication.Services;

namespace TicketApi.Features.Requirements.Services
{
    public class RequirementService : IRequirementsServices
    {
        private readonly RequirementsDbContext _context;
        private readonly IUserService _userService;
        private readonly ILogger<RequirementService> _logger;

        public RequirementService(
            RequirementsDbContext context,
            IUserService userService,
            ILogger<RequirementService> logger)
        {
            _context = context;
            _userService = userService;
            _logger = logger;
        }

        // ✅ CREATE - Mit deiner echten Entity Struktur
        public async Task<RequirementDto> CreateRequirementAsync(CreateRequirementRequest request)
        {
            _logger.LogInformation("Creating new requirement: {Title}", request.Title);

            var currentUser = await _userService.GetCurrentUserIdAsync();
            var now = DateTime.UtcNow;

            var entity = new Requirement
            {
                Id = Guid.NewGuid(),
                RequirementNumber = await GenerateRequirementNumberAsync(),
                Title = request.Title,
                Description = request.Description,
                RequirementType = request.RequirementType,
                Priority = request.Priority ?? "Medium",
                Status = "Draft",
                RequestedBy = currentUser,
                BusinessOwner = request.BusinessOwner,
                TechnicalOwner = request.TechnicalOwner,
                Department = request.Department,
                CostCenter = request.CostCenter, 
                EstimatedCost = request.EstimatedCost,
                Currency = request.Currency ?? "EUR", 

                
                RequestedDate = now,
                RequiredByDate = request.RequiredByDate,
                StartDate = request.StartDate,
                CreatedAt = now,
                ModifiedAt = now,

                HasPersonalData = request.HasPersonalData,
                SecurityClassification = request.SecurityClassification ?? "Internal",
                CreatedBy = currentUser,
                ModifiedBy = currentUser,

                
                FormConfigurationId = request.FormConfigurationId,
                FormData = request.FormData != null ? JsonConvert.SerializeObject(request.FormData) : null
            };

            _context.Requirements.Add(entity);
            await _context.SaveChangesAsync();

            _logger.LogInformation("Created requirement {Id} with number {Number}", entity.Id, entity.RequirementNumber);

            return entity.ToDto();
        }

        public async Task<RequirementDto?> GetRequirementByIdAsync(Guid id)
        {
            _logger.LogInformation("Getting requirement by id: {Id}", id);

            var requirement = await _context.Requirements
                .Include(r => r.CurrentWorkflowConfig) 
                .Include(r => r.FormConfiguration)     
                .Include(r => r.RequirementAttachments)
                .Include(r => r.RequirementComments)   
                .FirstOrDefaultAsync(r => r.Id == id);

            if (requirement == null)
            {
                _logger.LogWarning("Requirement with id {Id} not found", id);
                return null;
            }

            return requirement.ToDto();
        }

        public async Task<List<RequirementDto>> GetRequirementsAsync(
            string? status = null,
            string? requirementType = null,
            string? assignedTo = null,
            string? department = null,
            int page = 1,
            int pageSize = 20)
        {
            _logger.LogInformation("Getting requirements with filters - Status: {Status}, Type: {Type}, Department: {Department}, Page: {Page}",
                status, requirementType, department, page);

            var query = _context.Requirements
                .Include(r => r.CurrentWorkflowConfig)
                .Include(r => r.FormConfiguration)
                .AsQueryable();

            if (!string.IsNullOrEmpty(status))
                query = query.Where(r => r.Status == status);

            if (!string.IsNullOrEmpty(requirementType))
                query = query.Where(r => r.RequirementType == requirementType);

            if (!string.IsNullOrEmpty(department))
                query = query.Where(r => r.Department == department);

            if (!string.IsNullOrEmpty(assignedTo))
                query = query.Where(r => r.RequestedBy == assignedTo || r.BusinessOwner == assignedTo || r.TechnicalOwner == assignedTo);

            var requirements = await query
                .OrderByDescending(r => r.CreatedAt) 
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return requirements.Select(r => r.ToDto()).ToList();
        }

        public async Task<RequirementDto?> UpdateRequirementAsync(Guid id, UpdateRequirementRequest request)
        {
            _logger.LogInformation("Updating requirement {Id}", id);

            var requirement = await _context.Requirements.FindAsync(id);
            if (requirement == null)
            {
                _logger.LogWarning("Requirement with id {Id} not found for update", id);
                return null;
            }

            var currentUser = await _userService.GetCurrentUserNameAsync();

            if (request.Title != null) requirement.Title = request.Title;
            if (request.Description != null) requirement.Description = request.Description;
            if (request.Priority != null) requirement.Priority = request.Priority;
            if (request.Status != null) requirement.Status = request.Status;
            if (request.BusinessOwner != null) requirement.BusinessOwner = request.BusinessOwner;
            if (request.TechnicalOwner != null) requirement.TechnicalOwner = request.TechnicalOwner;
            if (request.Department != null) requirement.Department = request.Department;
            if (request.CostCenter != null) requirement.CostCenter = request.CostCenter; 
            if (request.Currency != null) requirement.Currency = request.Currency; 

            if (request.EstimatedCost.HasValue) requirement.EstimatedCost = request.EstimatedCost;
            if (request.ApprovedBudget.HasValue) requirement.ApprovedBudget = request.ApprovedBudget;
            if (request.ActualCost.HasValue) requirement.ActualCost = request.ActualCost;

            if (request.RequiredByDate.HasValue) requirement.RequiredByDate = request.RequiredByDate;
            if (request.StartDate.HasValue) requirement.StartDate = request.StartDate;
            if (request.CompletedDate.HasValue) requirement.CompletedDate = request.CompletedDate;

            if (request.CurrentWorkflowStep != null) requirement.CurrentWorkflowStep = request.CurrentWorkflowStep;
            if (request.CurrentWorkflowConfigId.HasValue) requirement.CurrentWorkflowConfigId = request.CurrentWorkflowConfigId;
            if (request.WorkflowInstanceId.HasValue) requirement.WorkflowInstanceId = request.WorkflowInstanceId;

            if (request.HasPersonalData.HasValue) requirement.HasPersonalData = request.HasPersonalData;
            if (request.SecurityClassification != null) requirement.SecurityClassification = request.SecurityClassification;
            if (request.ComplianceFlags != null) requirement.ComplianceFlags = request.ComplianceFlags; // ✅ Dein Feld

            // ✅ Form Data Update
            if (request.FormData != null)
                requirement.FormData = JsonConvert.SerializeObject(request.FormData);

            // ✅ ModifiedAt wird IMMER aktualisiert
            requirement.ModifiedAt = DateTime.UtcNow;
            requirement.ModifiedBy = currentUser;

            await _context.SaveChangesAsync();

            _logger.LogInformation("Updated requirement {Id}", id);

            // ✅ Reload mit Navigation Properties für DTO
            var updated = await _context.Requirements
                .Include(r => r.CurrentWorkflowConfig)
                .Include(r => r.FormConfiguration)
                .FirstOrDefaultAsync(r => r.Id == id);

            return updated?.ToDto();
        }

        // ✅ DELETE - Soft Delete
        public async Task<bool> DeleteRequirementAsync(Guid id)
        {
            _logger.LogInformation("Deleting requirement {Id}", id);

            var requirement = await _context.Requirements.FindAsync(id);
            if (requirement == null)
            {
                _logger.LogWarning("Requirement with id {Id} not found for deletion", id);
                return false;
            }

            var currentUser = await _userService.GetCurrentUserIdAsync();

            // ✅ Soft Delete - Status auf "Deleted" setzen
            requirement.Status = "Deleted";
            requirement.ModifiedAt = DateTime.UtcNow;
            requirement.ModifiedBy = currentUser;

            await _context.SaveChangesAsync();

            _logger.LogInformation("Soft deleted requirement {Id}", id);
            return true;
        }

        // ✅ GET REQUIREMENTS BY TYPE
        public async Task<List<RequirementDto>> GetRequirementsByTypeAsync(string requirementType)
        {
            _logger.LogInformation("Getting requirements by type: {Type}", requirementType);

            var requirements = await _context.Requirements
                .Include(r => r.CurrentWorkflowConfig)
                .Include(r => r.FormConfiguration)
                .Where(r => r.RequirementType == requirementType && r.Status != "Deleted")
                .OrderByDescending(r => r.CreatedAt)
                .ToListAsync();

            return requirements.Select(r => r.ToDto()).ToList();
        }

        public async Task<List<RequirementDto>> GetMyRequirementsAsync()
        {
            var currentUser = await _userService.GetCurrentUserIdAsync();

            _logger.LogInformation("Getting requirements for user: {User}", currentUser);

            var requirements = await _context.Requirements
                .Include(r => r.CurrentWorkflowConfig)
                .Include(r => r.FormConfiguration)
                .Where(r => r.RequestedBy == currentUser ||
                           r.BusinessOwner == currentUser ||
                           r.TechnicalOwner == currentUser)
                .Where(r => r.Status != "Deleted")
                .OrderByDescending(r => r.CreatedAt)
                .ToListAsync();

            return requirements.Select(r => r.ToDto()).ToList();
        }

        public async Task<bool> UpdateWorkflowStateAsync(Guid id, string workflowStep, Guid? workflowInstanceId = null)
        {
            _logger.LogInformation("Updating workflow state for requirement {Id} to step {Step}", id, workflowStep);

            var requirement = await _context.Requirements.FindAsync(id);
            if (requirement == null) return false;

            var currentUser = await _userService.GetCurrentUserIdAsync();

            requirement.CurrentWorkflowStep = workflowStep;
            if (workflowInstanceId.HasValue)
                requirement.WorkflowInstanceId = workflowInstanceId;

            requirement.ModifiedAt = DateTime.UtcNow;
            requirement.ModifiedBy = currentUser;

            await _context.SaveChangesAsync();

            _logger.LogInformation("Updated workflow state for requirement {Id}", id);
            return true;
        }

        private async Task<string> GenerateRequirementNumberAsync()
        {
            var year = DateTime.Now.Year;
            var count = await _context.Requirements
                .CountAsync(r => r.CreatedAt.HasValue && r.CreatedAt.Value.Year == year);

            return $"REQ-{year}-{count + 1:D4}";
        }

        public async Task<RequirementStatisticsDto> GetRequirementStatisticsAsync()
        {
            _logger.LogInformation("Getting requirement statistics");

            var totalRequirements = await _context.Requirements
                .CountAsync(r => r.Status != "Deleted");

            var statusCounts = await _context.Requirements
                .Where(r => r.Status != "Deleted")
                .GroupBy(r => r.Status)
                .Select(g => new { Status = g.Key, Count = g.Count() })
                .ToListAsync();

            var typeCounts = await _context.Requirements
                .Where(r => r.Status != "Deleted")
                .GroupBy(r => r.RequirementType)
                .Select(g => new { Type = g.Key, Count = g.Count() })
                .ToListAsync();

            var averageCost = await _context.Requirements
                .Where(r => r.EstimatedCost.HasValue && r.Status != "Deleted")
                .AverageAsync(r => r.EstimatedCost.Value);

            return new RequirementStatisticsDto
            {
                TotalRequirements = totalRequirements,
                StatusDistribution = statusCounts.ToDictionary(x => x.Status ?? "Unknown", x => x.Count),
                TypeDistribution = typeCounts.ToDictionary(x => x.Type, x => x.Count),
                AverageEstimatedCost = (decimal)averageCost
            };
        }
    }
}
